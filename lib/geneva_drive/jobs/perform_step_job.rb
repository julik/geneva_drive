# frozen_string_literal: true

# ActiveJob that executes a scheduled step execution.
# This is a thin wrapper that delegates all logic to the Executor.
#
# Idempotency is guaranteed by the Executor, which:
# - Acquires locks on both workflow and step execution
# - Reloads records after acquiring locks to get fresh state
# - Only proceeds if state is still "scheduled"
# - Transitions state atomically while holding locks
#
# @example Manual execution (for testing)
#   PerformStepJob.perform_now(step_execution.id)
#
class GenevaDrive::PerformStepJob < ActiveJob::Base
  # == CRITICAL: Prevent double-deferral of job enqueueing ==
  #
  # GenevaDrive already defers job enqueueing using `ActiveRecord.after_all_transactions_commit`
  # in Workflow#create_step_execution and Workflow#enqueue_scheduled_execution. By the time
  # `perform_later` is called, all step execution data has been committed and is visible.
  #
  # Without this setting, a dangerous double-deferral race condition can occur on Rails 7.2+
  # with queue adapters like SolidQueue that opt into `enqueue_after_transaction_commit`:
  #
  #   1. Workflow completes a step inside a transaction (with_lock)
  #   2. Transaction commits -> `after_all_transactions_commit` callback fires
  #   3. Inside the callback, `perform_later` is called
  #   4. ActiveJob checks `current_transaction.open?` -- which may return true because
  #      the transaction has committed but is not yet cleaned up on the Ruby side
  #   5. ActiveJob defers the INSERT into the queue backend to "after this transaction commits"
  #   6. But this transaction is ALREADY past its commit phase -- the deferred INSERT is lost
  #   7. The StepExecution gets a job_id (UUID generated by ActiveJob constructor) but
  #      no corresponding job row exists in the queue backend (e.g. solid_queue_jobs)
  #   8. The step hangs in "scheduled" state until HousekeepingJob recovers it (default: 15 min)
  #
  # The geneva_drive_step_executions table functions as a transactional outbox: it is the
  # committed source of truth for what work needs to happen. HousekeepingJob periodically
  # scans for step executions stuck in "scheduled" state and re-enqueues them, so the
  # system _does_ self-heal. But that recovery only kicks in after `stuck_scheduled_threshold`
  # (default: 15 minutes), which is far too slow for a workflow engine that is supposed to be
  # the reliable scheduler at the heart of the application. Losing a job enqueue means a
  # step that should run in milliseconds instead waits an hour. ActiveJob `perform_later`
  # is the closest thing Rails gives us to a reliable "schedule this work" primitive, so
  # we take stringent measures to ensure the INSERT into the queue backend actually lands
  # every single time -- the outbox recovery is a safety net, not the primary mechanism.
  #
  # By setting `:never`, `perform_later` writes the job row synchronously when called,
  # which is safe because we are already outside any application transaction
  # (the `after_all_transactions_commit` callback guarantees this).
  #
  # We _extremely deliberately_ deviate from the `:default` value here. The `:default`
  # setting tells ActiveJob to ask the queue adapter whether to defer (via the adapter's
  # `enqueue_after_transaction_commit?` method). Adapters like SolidQueue return `true`,
  # which re-enables the double-deferral. We MUST override this to `:never` because
  # GenevaDrive handles its own transaction-awareness via `after_all_transactions_commit`.
  #
  # This is timing-dependent and intermittent -- under normal conditions the transaction
  # may be fully cleaned up before `perform_later` checks `current_transaction.open?`,
  # so the INSERT happens immediately. Under load, during deploys (connection pool churn),
  # or with specific timing, the transaction is still on the stack and the INSERT is
  # silently deferred into the void.
  #
  # The `respond_to?` guard ensures compatibility with Rails versions before 7.2 that
  # do not have this class attribute.
  if respond_to?(:enqueue_after_transaction_commit=)
    self.enqueue_after_transaction_commit = :never
  end

  queue_as :default

  # Performs the step execution.
  #
  # @param step_execution_id [Integer, String] the ID of the step execution
  # @return [void]
  def perform(step_execution_id)
    step_execution = find_step_execution(step_execution_id)

    unless step_execution
      logger.warn("StepExecution #{step_execution_id} not found, skipping")
      return
    end

    step_execution.logger.debug("PerformStepJob starting execution")
    GenevaDrive::Executor.execute!(step_execution)
  end

  private

  # Retries the step execution lookup briefly to handle the (unlikely) case where
  # the job is picked up before the step execution's transaction is visible to this
  # database connection.
  #
  # This is a defense-in-depth measure. The primary protection against visibility
  # issues is the combination of:
  #   1. `after_all_transactions_commit` in Workflow#create_step_execution, which ensures
  #      `perform_later` is only called after the step execution row is committed
  #   2. `enqueue_after_transaction_commit = :never` (above), which ensures the queue
  #      adapter INSERT happens synchronously, not deferred into a dead callback
  #
  # However, this retry handles additional edge cases:
  #   - Database replication lag (read replica hasn't caught up with the writer)
  #   - Future code paths that might call perform_later inside a transaction
  #   - Any other visibility delay between the commit and the job worker's read
  #
  # The 500ms total window (5 x 100ms) is generous enough to handle typical
  # replication lag while being short enough to fail fast if the record truly
  # doesn't exist (e.g. it was already deleted by cleanup).
  #
  # @param id [Integer, String] the step execution ID to look up
  # @param attempts [Integer] maximum number of lookup attempts
  # @param delay [Float] seconds to sleep between attempts
  # @return [GenevaDrive::StepExecution, nil] the step execution or nil if not found
  def find_step_execution(id, attempts: 5, delay: 0.1)
    attempts.times do |i|
      record = GenevaDrive::StepExecution.find_by(id: id)
      return record if record
      sleep(delay) if i < attempts - 1
    end
    nil
  end
end
